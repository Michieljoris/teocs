(in-package :compilation-engine)

(setf (readtable-case *readtable*) :invert)
(defparameter class-symbol-table nil)
(defparameter subroutine-symbol-table nil)
(defparameter classname nil)
(defparameter subroutine-name nil)
(defparameter index 0)
(defparameter index-static 0)
(defparameter newline (string (coerce '(#\Newline) 'string)))
(defparameter operands '(( "+" . "add") ( "-" . "sub")
			 ( "*" . "Math.multiply 2") ( "/" . "Math.divide 2")
			 ( "=" . "eq") ( "<" . "lt") ( ">" . "gt")
			 ( "&" . "and")  ( "|" . "or") ))
(defun init ()
  (setf index 0)
  (setf index-static 0)
  (setf class-symbol-table nil)
  )

(defun @class (identifier
		  class-var-declaration-list
		  subroutine-declaration-list)
  (setf classname identifier)
  (format t "~&creating class [~a] with ~a varDec lines and ~a subroutines~%"
  	  identifier (length class-var-declaration-list)
  	  (length subroutine-declaration-list))
  
  )

(defun @className (identifier) identifier )
(defun @classNameDec (identifier) (setf classname identifier))
(defun @type (identifier-type) identifier-type) 
(defun @varName (identifier) identifier)
(defun @subroutineName (identifier) identifier)
(defun @subroutineNameDec (identifier)
  (setf index 0)
  (setf subroutine-symbol-table nil)
  (setf subroutine-name identifier))

(defun @classVarDec (kind type varname varnamelist)
  (push varname varnamelist)
  (do () ((null varnamelist))
    (push (list kind type
		(if (eql kind 'field) index index-static) )
	  class-symbol-table)
    (push (pop varnamelist) class-symbol-table)
    (if (eql kind 'field) (incf index) (incf index-static))))
    
(defun @subroutineDec (subroutineType returnType subroutineName
		       parameterList subroutineBody)
  
  )
(defun @parameterList (parameterType parameterName parameterList)
  (push parameterName parameterList)
  (push parameterType parameterList)
  (let ((index 0))
    (do () ((null parameterList))
      (push (list 'argument (pop parameterList) index) subroutine-symbol-table)
      (push (pop parameterList) subroutine-symbol-table)
      (incf index))))

(defun @subroutineBody (varList statementList))
(defun @varDec (varType varName varList)
  (push varName varList)
  (do () ((null varList))
    (push (list 'local varType index) subroutine-symbol-table)
    (push (pop varList) subroutine-symbol-table)
    (incf index))
  (cmd t "function" (format nil "~a.~a" classname  subroutine-name) index))
  
(defun @statement (statement))
(defun @doStatement (subroutineCall))
(defun @letStatement (varName index-expression sign expression)
 ;??????index-expression... 
 (cmd t expression)
 (cmd t "pop" (kind-of varName) (index-of varName))
  )
(defun @ifStatement (expression statementList elseList))
(defun @whileStatement (expression statementList))
(defun @returnStatement (expression)
  (if expression (cmd t expression)
    (cmd t "push constant 0"))
  (cmd t "return"))

(defun @expressionList (expression expressionList))
(defun @expression (term optermList)
  (with-output-to-string
    (string-out)
    (cmd string-out term)
    (do ((op optermList (cddr op))
	 (term (cdr optermList) (cddr term)))
	((null op))
      (cmd string-out (car term))
      (cmd string-out (car op)))))
(defun @op (operand) (cmd nil (cdr (assoc operand operands :test #'equal))))

;term factors
(defun @term (term) term)
(defun @integer (integer) (cmd nil "push constant" integer))
(defun @string (string)
  (with-output-to-string
    (string-out)
    (cmd string-out "push" "constant" (length string) )
    (cmd string-out "call String.new 1")
    (dotimes (i (length string))
      (cmd string-out "push constant" (char-code (elt string i)))
      (cmd string-out "call String.appendChar 2"))))
(defun @keywordConstant (keywordConstant))
(defun @variable (varName expression))
(defun @localCall (subroutineName expressionList))
(defun @classCall (varName subroutineName expressionList))
(defun @parensedExpression (expression) expression)
(defun @unaryOppedTerm (unaryOp term))

(defun @unaryOp (unaryOp))
;---------------------------------------------------
;support functions
(defun kind-of (identifier)
  (symbol-name (car (lookup identifier))))
(defun typeof (identifier)
  (symbol-name (cadr (lookup identifier))))
(defun index-of (identifier)
  (caddr (lookup identifier)))
(defun lookup (identifier)
  (or (getf subroutine-symbol-table identifier)
      (getf class-symbol-table identifier)))
(defun cmd (stream &rest l) (format stream "~&~{~a ~}" l)) 
;------------------------------------------
;
(defun eval-jack (jack-filename language-definition-filename )
  (let* ((sexpr-string (get-sexpr-string jack-filename language-definition-filename))
	 (sexpr ))
    (in-package :compilation-engine)
    (setf sexpr (read-from-string sexpr-string))
    (pprint sexpr)
    (init)
     (eval sexpr)
    (format t "~&class symbol table :~%~{ ~a ~a~%~}" class-symbol-table)
    (format t "~&subroutine symbol table :~%~{ ~a ~a~%~}" subroutine-symbol-table)
    ))

(eval-jack "c:/home/mysrc/lisp/eocs/11/Pong/test.jack"
	    "c:/home/mysrc/lisp/eocs/jack-compiler/jack-def-test.txt")
